module;

#include <iostream>

export module Ray;

import Vector;

using Vector3f = math::Vector<float, 3>;

export namespace ray {

/*! @brief Ray class. */
class Ray {
private:
    /*! @brief Origin. */
    Vector3f origin;
    /*! @brief Direction. */
    Vector3f direction;

public:
    /*! @brief Default constructor. */
    Ray() noexcept = default;

    /*! @brief Copy constructor. */
    Ray(const Ray&) noexcept = default;

    /*! @brief Move constructor. */
    Ray(Ray&&) noexcept = default;

    /*! @brief Copy constructor that accepts vectors. */
    explicit Ray(const Vector3f& origin, const Vector3f& direction) noexcept :
        origin{origin}, direction{direction} {}

    /*! @brief Move constructor that accepts vectors. */
    explicit Ray(Vector3f&& origin, Vector3f&& direction) noexcept :
        origin{std::move(origin)}, direction{std::move(direction)} {}

    /*! @brief Copy assignment operator. */
    inline Ray& operator=(const Ray&) noexcept = default;

    /*! @brief Move assignment operator. */
    inline Ray& operator=(Ray&&) noexcept = default;

    /*! @brief Get origin. */
    inline auto Origin() const noexcept { return origin; }

    /*! @brief Get direction. */
    inline auto Direction() const noexcept { return direction; }

    /**
     * @brief Get point at given distance along ray.
     * @tparam U Type of distance number.
     * @param distance Distance along ray.
     * @return Point at specified distance along ray.
     */
    template<math::Arithmetic U>
    inline auto PointAt(const U distance) const noexcept {
        return origin + direction * distance;
    }

    /*! @brief Output stream << operator. */
    friend std::ostream& operator<<(std::ostream& out, const Ray& ray) {
        return out << ray.origin << " -> " << ray.direction;
    }
};

} // namespace ray
